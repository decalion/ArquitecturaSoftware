###QUE SON LOS PRINCIPIO SOLIID###
	Principios o convenciones de dise√±o de Software
	Ampliamente aceptados en la industria
	Ayudan a hacer un c√≥digo m√°s mantenible y tolerante a cambios
	Aplicables en t√©rminos de dise√±o de clases (micro-dise√±o), y tambi√©n a nivel de arquitectura de software y estructura de [micro]servicios (macro-dise√±o)
	Tenemos que romper con el rol de ‚ÄúArquitecto de software‚Äù. Entender el dise√±o de software de calidad como una habilidad y no un rol
	
	S.O.L.I.D
		S = SRP
		O = OCP
		L = LSP
		I = ISP
		D = DIP
	
	###SOLID vs STUPID###
		Singleton:
		Tight Coupling:
			Acoplamiento entre clases que dificulta la mantenibilidad y tolerancia al cambio que proporciona la aplicaci√≥n de principios SOLID
		Untestability: 
			C√≥digo dif√≠cil de testear. Derivado de no inyectar dependencias v√≠a constructor nos vemos obligados al uso de costuras en nuestro c√≥digo.
		Premature Optimization: 
			Anticiparnos a los requisitos de nuestro software desarrollando abstracciones innecesarias que a√±aden complejidad.
		Indescriptive Naming: 
			Nomenclatura indescriptiva tanto a nivel de clases, como variables o atributos. ¬°Hablaremos m√°s de esto en el curso de Clean Code!
		Duplication: 
			Duplicidad de c√≥digo. Algo solucionable si aplicamos el Principio de Responsabilidad √önica de SOLID e inyecci√≥n de dependencias como veremos en este curso

###DIGRAMA - UML###
	###CASOS DE USO###
		Se trata de un tipo de diagrama que permite visualizar las funcionalidades de nuestra aplicaci√≥n. 
		Esto mismo se traducir√° despu√©s en nuestro c√≥digo como casos de uso/application services
		
	###SECUENCIA###
		Se trata de un diagrama con el que podremos ver el flujo de nuestra aplicaci√≥n, 
		representando c√≥mo interaccionan las clases (comunicaci√≥n entre objetos)
	
	###CLASES##
		Este tipo de diagramas son muy populares y nos permiten ver no s√≥lo los atributos y m√©todos de cada clase, 
		sino tambi√©n las diferentes relaciones de herencia, interfaces e implementaciones de √©stas.
		


###Principio de Responsabilidad √önica (SRP) ###
	Concepto:
		Una clase = Un concepto y responsabilidad
		Una clase deber√≠a tener s√≥lo 1 raz√≥n para cambiar
	C√≥mo conseguirlo:
		Clases peque√±as con objetivos acotados
	Finalidad:
		Alta cohesi√≥n y robustez
		Permitir composici√≥n de clases (inyectar colaboradores)
		Evitar duplicidad de c√≥digo
		

###Principio de Abierto/Cerrado (OCP) ###
	Concepto:
		El Software deber√≠a estar abierto a extensi√≥n y cerrado a modificaci√≥n.
		Esto aplica tanto a nuestras clases internas, servicios, microservicios, casos de usos‚Ä¶
	C√≥mo conseguirlo:
		Evitando depender de implementaciones espec√≠ficas, haciendo uso de clases abstractas o interfaces.
	Finalidad:
		Facilidad para a√±adir nuevos Casos de uso en nuestra aplicaci√≥n.
		
	###Interfaces vs Abstract Class###
		Beneficios de Interface:
			No modifica el √°rbol de jerarqu√≠a
			Permite implementar N Interfaces
		Beneficios de Abstract Class:
			Permite desarrollar el patr√≥n Template Method[^1] empujando la l√≥gica al modelo
				Problema: Dificultad de trazar
			Getters privados (Tell don‚Äôt ask)
		
		¬øCu√°ndo usamos Interfaces?: Cuando vayamos a desacoplar entre capas
		¬øCu√°ndo usamos Abstract?: En determinados casos para Modelos de dominios


###Principio de Substitucion Liskov (LSP) ###

	Concepto:
		Si S es un subtipo de T, instancias de T deber√≠an poderse sustituir por instancias de S sin alterar las propiedades del programa
		Es decir, al tener una jerarqu√≠a nos supone que estamos estableciendo un contrato en el padre, por lo que, garantizar que se mantiene dicho contrato en el hijo, nos permitir√° que podamos sustituir al padre y la aplicaci√≥n seguir√° funcionando perfectamente üëå
	C√≥mo:
		El comportamiento de de las subclases debe respetar el contrato establecido en la superclase.
	Finalidad:
		Mantener correctitud funcional para poder aplicar OCP


		
###Principio de Segregaci√≥n de Interfaces (ISP) ###

	Concepto:
		Ning√∫n cliente deber√≠a verse forzado a depender de m√©todos que no usa
	C√≥mo:
		Definir contratos de interfaces bas√°ndonos en los clientes que las usan y no en las implementaciones que pudi√©ramos tener (Las interfaces pertenecen a los clientes)
		Evitar Header Interfaces promoviendo Role Interfaces
	Finalidad:
		Alta cohesi√≥n y bajo acoplamiento estructural
		
	###Ejemplo Sencillo###

		Queremos poder enviar notificaciones v√≠a email, Slack, o fichero txt ¬øQu√© firma tendr√° la interface? üì®
			a) $notifier($content)
			b) $notifier($slackChannel, $messageTitle, $messageContent, $messageStatus) ‚ùå
			c) $notifier($recieverEmail, $emailSubject, $emailContent) ‚ùå
			d) $notifier($destination, $subject, $content) ‚ùå
			e) $notifier($filename, $tag, $description) ‚ùå

		Podemos descartar que las opciones B, C y E fueran interfaces v√°lidas, puesto que se estar√≠a haciendo
		Header Interface en base a la implementaci√≥n (para Slack, email y fichero respectivamente).

		En el caso de la opci√≥n D, podr√≠amos considerarlo inv√°lido dado que el tipo $destination no nos ofrece ninguna especificidad (no sabemos si es un email, un canal‚Ä¶).

		Por √∫ltimo, en la opci√≥n A, s√≥lo estar√≠amos enviando el contenido, por lo que las particularidades de cada uno de los tipos de notificaci√≥n tendr√≠an que venir dados en el constructor (dependiendo del caso de uso no siempre se podr√≠a).


		Las interfaces pertenecen a los clientes y no a quienes las implementan
		Diferencia: Nivel de abstracci√≥n de la implementaci√≥n
			a) Si sabemos destinatario en tiempo de compilaci√≥n (par√°metros por constructor)
			d) Si no sabemos destinatario hasta tiempo de ejecuci√≥n (perdemos el tipado)
			f) Dos subscribers diferentes (email y slack) que leen de m√≥dulos‚Ä¶
			


### Principio de Inversi√≥n de Dependencias (DIP)###

	Concepto:
		M√≥dulos de alto nivel no deber√≠an depender de los de bajo nivel. Ambos deber√≠an depender de abstracciones
	C√≥mo:
		Inyectar dependencias (par√°metros recibidos en constructor)
		Depender de las interfaces (contratos) de estas dependencias y no de implementaciones concretas
		LSP como premisa
	Finalidad:
		Facilitar la modificaci√≥n y substituci√≥n de implementaciones
		Mejor testabilidad de clases
		

































































































